// Generated by Haxe 4.3.3
#ifndef INCLUDED_hx_concurrent_lock_Acquirable
#define INCLUDED_hx_concurrent_lock_Acquirable

#ifndef HXCPP_H
#include <hxcpp.h>
#endif

HX_DECLARE_CLASS3(hx,concurrent,lock,Acquirable)

namespace hx{
namespace concurrent{
namespace lock{


class HXCPP_CLASS_ATTRIBUTES Acquirable_obj {
	public:
		typedef ::hx::Object super;
		HX_DO_INTERFACE_RTTI;

		int (::hx::Object :: *_hx_get_availablePermits)(); 
		static inline int get_availablePermits( ::Dynamic _hx_) {
			return (_hx_.mPtr->*( ::hx::interface_cast< ::hx::concurrent::lock::Acquirable_obj *>(_hx_.mPtr->_hx_getInterface(0x3a6fb49b)))->_hx_get_availablePermits)();
		}
		void (::hx::Object :: *_hx_acquire)(); 
		static inline void acquire( ::Dynamic _hx_) {
			(_hx_.mPtr->*( ::hx::interface_cast< ::hx::concurrent::lock::Acquirable_obj *>(_hx_.mPtr->_hx_getInterface(0x3a6fb49b)))->_hx_acquire)();
		}
		bool (::hx::Object :: *_hx_tryAcquire)(::hx::Null< int >  timeoutMS); 
		static inline bool tryAcquire( ::Dynamic _hx_,::hx::Null< int >  timeoutMS) {
			return (_hx_.mPtr->*( ::hx::interface_cast< ::hx::concurrent::lock::Acquirable_obj *>(_hx_.mPtr->_hx_getInterface(0x3a6fb49b)))->_hx_tryAcquire)(timeoutMS);
		}
		void (::hx::Object :: *_hx_release)(); 
		static inline void release( ::Dynamic _hx_) {
			(_hx_.mPtr->*( ::hx::interface_cast< ::hx::concurrent::lock::Acquirable_obj *>(_hx_.mPtr->_hx_getInterface(0x3a6fb49b)))->_hx_release)();
		}
		 ::Dynamic (::hx::Object :: *_hx_execute)( ::Dynamic func,::hx::Null< bool >  swallowExceptions); 
		static inline  ::Dynamic execute( ::Dynamic _hx_, ::Dynamic func,::hx::Null< bool >  swallowExceptions) {
			return (_hx_.mPtr->*( ::hx::interface_cast< ::hx::concurrent::lock::Acquirable_obj *>(_hx_.mPtr->_hx_getInterface(0x3a6fb49b)))->_hx_execute)(func,swallowExceptions);
		}
};

} // end namespace hx
} // end namespace concurrent
} // end namespace lock

#endif /* INCLUDED_hx_concurrent_lock_Acquirable */ 
