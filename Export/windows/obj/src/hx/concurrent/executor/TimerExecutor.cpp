// Generated by Haxe 4.3.3
#include <hxcpp.h>

#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_hx_concurrent_AbstractFuture
#include <hx/concurrent/AbstractFuture.h>
#endif
#ifndef INCLUDED_hx_concurrent_CompletableFuture
#include <hx/concurrent/CompletableFuture.h>
#endif
#ifndef INCLUDED_hx_concurrent_Future
#include <hx/concurrent/Future.h>
#endif
#ifndef INCLUDED_hx_concurrent_Service
#include <hx/concurrent/Service.h>
#endif
#ifndef INCLUDED_hx_concurrent_ServiceBase
#include <hx/concurrent/ServiceBase.h>
#endif
#ifndef INCLUDED_hx_concurrent_ServiceState
#include <hx/concurrent/ServiceState.h>
#endif
#ifndef INCLUDED_hx_concurrent_executor_AbstractTaskFuture
#include <hx/concurrent/executor/AbstractTaskFuture.h>
#endif
#ifndef INCLUDED_hx_concurrent_executor_Executor
#include <hx/concurrent/executor/Executor.h>
#endif
#ifndef INCLUDED_hx_concurrent_executor_Schedule
#include <hx/concurrent/executor/Schedule.h>
#endif
#ifndef INCLUDED_hx_concurrent_executor_TaskFuture
#include <hx/concurrent/executor/TaskFuture.h>
#endif
#ifndef INCLUDED_hx_concurrent_executor_TimerExecutor
#include <hx/concurrent/executor/TimerExecutor.h>
#endif
#ifndef INCLUDED_hx_concurrent_executor__TimerExecutor_TaskFutureImpl
#include <hx/concurrent/executor/_TimerExecutor/TaskFutureImpl.h>
#endif
#ifndef INCLUDED_hx_concurrent_internal__Either2__Either2
#include <hx/concurrent/internal/_Either2/_Either2.h>
#endif
#ifndef INCLUDED_hx_concurrent_lock_AbstractAcquirable
#include <hx/concurrent/lock/AbstractAcquirable.h>
#endif
#ifndef INCLUDED_hx_concurrent_lock_Acquirable
#include <hx/concurrent/lock/Acquirable.h>
#endif
#ifndef INCLUDED_hx_concurrent_lock_RLock
#include <hx/concurrent/lock/RLock.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_6a55b9f9fdfdc896_18_new,"hx.concurrent.executor.TimerExecutor","new",0xed1bce28,"hx.concurrent.executor.TimerExecutor.new","hx/concurrent/executor/TimerExecutor.hx",18,0x40659ea9)
HX_LOCAL_STACK_FRAME(_hx_pos_6a55b9f9fdfdc896_34_submit,"hx.concurrent.executor.TimerExecutor","submit",0x62cd2750,"hx.concurrent.executor.TimerExecutor.submit","hx/concurrent/executor/TimerExecutor.hx",34,0x40659ea9)
HX_LOCAL_STACK_FRAME(_hx_pos_6a55b9f9fdfdc896_32_submit,"hx.concurrent.executor.TimerExecutor","submit",0x62cd2750,"hx.concurrent.executor.TimerExecutor.submit","hx/concurrent/executor/TimerExecutor.hx",32,0x40659ea9)
HX_LOCAL_STACK_FRAME(_hx_pos_6a55b9f9fdfdc896_53_onStop,"hx.concurrent.executor.TimerExecutor","onStop",0xb7acc7f9,"hx.concurrent.executor.TimerExecutor.onStop","hx/concurrent/executor/TimerExecutor.hx",53,0x40659ea9)
namespace hx{
namespace concurrent{
namespace executor{

void TimerExecutor_obj::__construct(::hx::Null< bool >  __o_autostart){
            		bool autostart = __o_autostart.Default(true);
            	HX_STACKFRAME(&_hx_pos_6a55b9f9fdfdc896_18_new)
HXLINE(  20)		this->_scheduledTasks = ::Array_obj< ::Dynamic>::__new(0);
HXLINE(  25)		super::__construct();
HXLINE(  27)		if (autostart) {
HXLINE(  28)			this->start();
            		}
            	}

Dynamic TimerExecutor_obj::__CreateEmpty() { return new TimerExecutor_obj; }

void *TimerExecutor_obj::_hx_vtable = 0;

Dynamic TimerExecutor_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< TimerExecutor_obj > _hx_result = new TimerExecutor_obj();
	_hx_result->__construct(inArgs[0]);
	return _hx_result;
}

bool TimerExecutor_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x7b12badf) {
		if (inClassId<=(int)0x576cdc1a) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x576cdc1a;
		} else {
			return inClassId==(int)0x7b12badf;
		}
	} else {
		return inClassId==(int)0x7e2f004d;
	}
}

::Dynamic TimerExecutor_obj::submit( ::hx::concurrent::internal::_Either2::_Either2 task, ::hx::concurrent::executor::Schedule schedule){
            		HX_BEGIN_LOCAL_FUNC_S3(::hx::LocalFunc,_hx_Closure_0, ::hx::concurrent::executor::TimerExecutor,_gthis, ::hx::concurrent::internal::_Either2::_Either2,task, ::hx::concurrent::executor::Schedule,schedule1) HXARGC(0)
            		 ::hx::concurrent::executor::_TimerExecutor::TaskFutureImpl _hx_run(){
            			HX_GC_STACKFRAME(&_hx_pos_6a55b9f9fdfdc896_34_submit)
HXLINE(  35)			if (::hx::IsPointerNotEq( _gthis->state,::hx::concurrent::ServiceState_obj::RUNNING_dyn() )) {
HXLINE(  36)				HX_STACK_DO_THROW(((HX_("Cannot accept new tasks. Executor is not in state [RUNNING] but [",06,f5,6c,89) + ::Std_obj::string(_gthis->state)) + HX_("].",31,51,00,00)));
            			}
HXLINE(  39)			int i = _gthis->_scheduledTasks->length;
HXLINE(  40)			while(true){
HXLINE(  40)				i = (i - 1);
HXDLIN(  40)				if (!(((i + 1) > 0))) {
HXLINE(  40)					goto _hx_goto_1;
            				}
HXLINE(  41)				if (_gthis->_scheduledTasks->__get(i).StaticCast<  ::hx::concurrent::executor::_TimerExecutor::TaskFutureImpl >()->isStopped) {
HXLINE(  41)					_gthis->_scheduledTasks->removeRange(i,1);
            				}
            			}
            			_hx_goto_1:;
HXLINE(  43)			 ::hx::concurrent::executor::_TimerExecutor::TaskFutureImpl future =  ::hx::concurrent::executor::_TimerExecutor::TaskFutureImpl_obj::__alloc( HX_CTX ,_gthis,task,schedule1);
HXLINE(  44)			if ((schedule1->_hx_getIndex() == 0)) {
HXLINE(  45)				 ::Dynamic _g = schedule1->_hx_getObject(0);
HXDLIN(  45)				if (::hx::IsNull( _g )) {
HXLINE(  46)					_gthis->_scheduledTasks->push(future);
            				}
            				else {
HXLINE(  45)					if (::hx::IsNotEq( _g,0 )) {
HXLINE(  46)						_gthis->_scheduledTasks->push(future);
            					}
            				}
            			}
            			else {
HXLINE(  46)				_gthis->_scheduledTasks->push(future);
            			}
HXLINE(  48)			return future;
            		}
            		HX_END_LOCAL_FUNC0(return)

            	HX_STACKFRAME(&_hx_pos_6a55b9f9fdfdc896_32_submit)
HXDLIN(  32)		 ::hx::concurrent::executor::TimerExecutor _gthis = ::hx::ObjectPtr<OBJ_>(this);
HXLINE(  33)		 ::hx::concurrent::executor::Schedule schedule1;
HXDLIN(  33)		if (::hx::IsNull( schedule )) {
HXLINE(  33)			schedule1 = ::hx::concurrent::executor::Executor_obj::NOW_ONCE;
            		}
            		else {
HXLINE(  33)			schedule1 = schedule;
            		}
HXLINE(  34)		return this->_stateLock->execute( ::Dynamic(new _hx_Closure_0(_gthis,task,schedule1)),null()).StaticCast<  ::hx::concurrent::executor::_TimerExecutor::TaskFutureImpl >();
            	}


void TimerExecutor_obj::onStop(){
            	HX_STACKFRAME(&_hx_pos_6a55b9f9fdfdc896_53_onStop)
HXLINE(  54)		{
HXLINE(  54)			int _g = 0;
HXDLIN(  54)			::Array< ::Dynamic> _g1 = this->_scheduledTasks;
HXDLIN(  54)			while((_g < _g1->length)){
HXLINE(  54)				 ::hx::concurrent::executor::_TimerExecutor::TaskFutureImpl t = _g1->__get(_g).StaticCast<  ::hx::concurrent::executor::_TimerExecutor::TaskFutureImpl >();
HXDLIN(  54)				_g = (_g + 1);
HXLINE(  55)				t->cancel();
            			}
            		}
HXLINE(  56)		this->_scheduledTasks = ::Array_obj< ::Dynamic>::__new(0);
            	}



::hx::ObjectPtr< TimerExecutor_obj > TimerExecutor_obj::__new(::hx::Null< bool >  __o_autostart) {
	::hx::ObjectPtr< TimerExecutor_obj > __this = new TimerExecutor_obj();
	__this->__construct(__o_autostart);
	return __this;
}

::hx::ObjectPtr< TimerExecutor_obj > TimerExecutor_obj::__alloc(::hx::Ctx *_hx_ctx,::hx::Null< bool >  __o_autostart) {
	TimerExecutor_obj *__this = (TimerExecutor_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(TimerExecutor_obj), true, "hx.concurrent.executor.TimerExecutor"));
	*(void **)__this = TimerExecutor_obj::_hx_vtable;
	__this->__construct(__o_autostart);
	return __this;
}

TimerExecutor_obj::TimerExecutor_obj()
{
}

void TimerExecutor_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(TimerExecutor);
	HX_MARK_MEMBER_NAME(_scheduledTasks,"_scheduledTasks");
	 ::hx::concurrent::executor::Executor_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void TimerExecutor_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(_scheduledTasks,"_scheduledTasks");
	 ::hx::concurrent::executor::Executor_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val TimerExecutor_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"submit") ) { return ::hx::Val( submit_dyn() ); }
		if (HX_FIELD_EQ(inName,"onStop") ) { return ::hx::Val( onStop_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"_scheduledTasks") ) { return ::hx::Val( _scheduledTasks ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val TimerExecutor_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 15:
		if (HX_FIELD_EQ(inName,"_scheduledTasks") ) { _scheduledTasks=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void TimerExecutor_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("_scheduledTasks",c0,10,ac,ec));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo TimerExecutor_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(TimerExecutor_obj,_scheduledTasks),HX_("_scheduledTasks",c0,10,ac,ec)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *TimerExecutor_obj_sStaticStorageInfo = 0;
#endif

static ::String TimerExecutor_obj_sMemberFields[] = {
	HX_("_scheduledTasks",c0,10,ac,ec),
	HX_("submit",18,58,06,9a),
	HX_("onStop",c1,f8,e5,ee),
	::String(null()) };

::hx::Class TimerExecutor_obj::__mClass;

void TimerExecutor_obj::__register()
{
	TimerExecutor_obj _hx_dummy;
	TimerExecutor_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("hx.concurrent.executor.TimerExecutor",36,da,c7,ec);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(TimerExecutor_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< TimerExecutor_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = TimerExecutor_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = TimerExecutor_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace hx
} // end namespace concurrent
} // end namespace executor
