// Generated by Haxe 4.3.3
#include <hxcpp.h>

#ifndef INCLUDED_hx_concurrent_AbstractFuture
#include <hx/concurrent/AbstractFuture.h>
#endif
#ifndef INCLUDED_hx_concurrent_CompletableFuture
#include <hx/concurrent/CompletableFuture.h>
#endif
#ifndef INCLUDED_hx_concurrent_Future
#include <hx/concurrent/Future.h>
#endif
#ifndef INCLUDED_hx_concurrent_FutureResult
#include <hx/concurrent/FutureResult.h>
#endif
#ifndef INCLUDED_hx_concurrent_Service
#include <hx/concurrent/Service.h>
#endif
#ifndef INCLUDED_hx_concurrent_ServiceBase
#include <hx/concurrent/ServiceBase.h>
#endif
#ifndef INCLUDED_hx_concurrent_executor_AbstractTaskFuture
#include <hx/concurrent/executor/AbstractTaskFuture.h>
#endif
#ifndef INCLUDED_hx_concurrent_executor_Executor
#include <hx/concurrent/executor/Executor.h>
#endif
#ifndef INCLUDED_hx_concurrent_executor_Schedule
#include <hx/concurrent/executor/Schedule.h>
#endif
#ifndef INCLUDED_hx_concurrent_executor_ScheduleTools
#include <hx/concurrent/executor/ScheduleTools.h>
#endif
#ifndef INCLUDED_hx_concurrent_executor_TaskFuture
#include <hx/concurrent/executor/TaskFuture.h>
#endif
#ifndef INCLUDED_hx_concurrent_internal__Either2__Either2
#include <hx/concurrent/internal/_Either2/_Either2.h>
#endif
#ifndef INCLUDED_hx_concurrent_thread_Threads
#include <hx/concurrent/thread/Threads.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_0d07713033fcafe7_130_new,"hx.concurrent.executor.AbstractTaskFuture","new",0xb964cb1e,"hx.concurrent.executor.AbstractTaskFuture.new","hx/concurrent/executor/Executor.hx",130,0xb24f9f08)
HX_LOCAL_STACK_FRAME(_hx_pos_0d07713033fcafe7_150_cancel,"hx.concurrent.executor.AbstractTaskFuture","cancel",0xc611bd7c,"hx.concurrent.executor.AbstractTaskFuture.cancel","hx/concurrent/executor/Executor.hx",150,0xb24f9f08)
HX_LOCAL_STACK_FRAME(_hx_pos_0d07713033fcafe7_155_awaitCompletion,"hx.concurrent.executor.AbstractTaskFuture","awaitCompletion",0x85ab55d0,"hx.concurrent.executor.AbstractTaskFuture.awaitCompletion","hx/concurrent/executor/Executor.hx",155,0xb24f9f08)
HX_LOCAL_STACK_FRAME(_hx_pos_0d07713033fcafe7_154_awaitCompletion,"hx.concurrent.executor.AbstractTaskFuture","awaitCompletion",0x85ab55d0,"hx.concurrent.executor.AbstractTaskFuture.awaitCompletion","hx/concurrent/executor/Executor.hx",154,0xb24f9f08)
namespace hx{
namespace concurrent{
namespace executor{

void AbstractTaskFuture_obj::__construct( ::hx::concurrent::executor::Executor executor, ::hx::concurrent::internal::_Either2::_Either2 task, ::hx::concurrent::executor::Schedule schedule){
            	HX_STACKFRAME(&_hx_pos_0d07713033fcafe7_130_new)
HXLINE( 133)		this->isStopped = false;
HXLINE( 141)		super::__construct();
HXLINE( 142)		this->_executor = executor;
HXLINE( 143)		this->_task = task;
HXLINE( 145)		this->schedule = ::hx::concurrent::executor::ScheduleTools_obj::assertValid(schedule);
            	}

bool AbstractTaskFuture_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x77d6e8d0) {
		if (inClassId<=(int)0x1af78b62) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x1af78b62;
		} else {
			return inClassId==(int)0x77d6e8d0;
		}
	} else {
		return inClassId==(int)0x7b9c8b84;
	}
}

static ::hx::concurrent::executor::TaskFuture_obj _hx_hx_concurrent_executor_AbstractTaskFuture__hx_hx_concurrent_executor_TaskFuture= {
	( bool (::hx::Object::*)())&::hx::concurrent::executor::AbstractTaskFuture_obj::isComplete,
	( void (::hx::Object::*)( ::Dynamic))&::hx::concurrent::executor::AbstractTaskFuture_obj::onCompletion,
	( void (::hx::Object::*)())&::hx::concurrent::executor::AbstractTaskFuture_obj::cancel,
	(  ::hx::concurrent::FutureResult (::hx::Object::*)(int))&::hx::concurrent::executor::AbstractTaskFuture_obj::awaitCompletion,
};

static ::hx::concurrent::Future_obj _hx_hx_concurrent_executor_AbstractTaskFuture__hx_hx_concurrent_Future= {
	( bool (::hx::Object::*)())&::hx::concurrent::executor::AbstractTaskFuture_obj::isComplete,
	( void (::hx::Object::*)( ::Dynamic))&::hx::concurrent::executor::AbstractTaskFuture_obj::onCompletion,
};

void *AbstractTaskFuture_obj::_hx_getInterface(int inHash) {
	switch(inHash) {
		case (int)0x5801c022: return &_hx_hx_concurrent_executor_AbstractTaskFuture__hx_hx_concurrent_executor_TaskFuture;
		case (int)0xdec70c2a: return &_hx_hx_concurrent_executor_AbstractTaskFuture__hx_hx_concurrent_Future;
	}
	return super::_hx_getInterface(inHash);
}

void AbstractTaskFuture_obj::cancel(){
            	HX_STACKFRAME(&_hx_pos_0d07713033fcafe7_150_cancel)
HXDLIN( 150)		this->isStopped = true;
            	}


HX_DEFINE_DYNAMIC_FUNC0(AbstractTaskFuture_obj,cancel,(void))

 ::hx::concurrent::FutureResult AbstractTaskFuture_obj::awaitCompletion(int timeoutMS){
            		HX_BEGIN_LOCAL_FUNC_S1(::hx::LocalFunc,_hx_Closure_0, ::hx::concurrent::executor::AbstractTaskFuture,_gthis) HXARGC(0)
            		bool _hx_run(){
            			HX_STACKFRAME(&_hx_pos_0d07713033fcafe7_155_awaitCompletion)
HXLINE( 155)			return _gthis->isComplete();
            		}
            		HX_END_LOCAL_FUNC0(return)

            	HX_STACKFRAME(&_hx_pos_0d07713033fcafe7_154_awaitCompletion)
HXDLIN( 154)		 ::hx::concurrent::executor::AbstractTaskFuture _gthis = ::hx::ObjectPtr<OBJ_>(this);
HXLINE( 155)		::hx::concurrent::thread::Threads_obj::await( ::Dynamic(new _hx_Closure_0(_gthis)),timeoutMS,10);
HXLINE( 156)		return this->result;
            	}


HX_DEFINE_DYNAMIC_FUNC1(AbstractTaskFuture_obj,awaitCompletion,return )


AbstractTaskFuture_obj::AbstractTaskFuture_obj()
{
}

void AbstractTaskFuture_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(AbstractTaskFuture);
	HX_MARK_MEMBER_NAME(schedule,"schedule");
	HX_MARK_MEMBER_NAME(isStopped,"isStopped");
	HX_MARK_MEMBER_NAME(_executor,"_executor");
	HX_MARK_MEMBER_NAME(_task,"_task");
	 ::hx::concurrent::AbstractFuture_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void AbstractTaskFuture_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(schedule,"schedule");
	HX_VISIT_MEMBER_NAME(isStopped,"isStopped");
	HX_VISIT_MEMBER_NAME(_executor,"_executor");
	HX_VISIT_MEMBER_NAME(_task,"_task");
	 ::hx::concurrent::AbstractFuture_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val AbstractTaskFuture_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"_task") ) { return ::hx::Val( _task ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"cancel") ) { return ::hx::Val( cancel_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"schedule") ) { return ::hx::Val( schedule ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"isStopped") ) { return ::hx::Val( isStopped ); }
		if (HX_FIELD_EQ(inName,"_executor") ) { return ::hx::Val( _executor ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"awaitCompletion") ) { return ::hx::Val( awaitCompletion_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val AbstractTaskFuture_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"_task") ) { _task=inValue.Cast<  ::hx::concurrent::internal::_Either2::_Either2 >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"schedule") ) { schedule=inValue.Cast<  ::hx::concurrent::executor::Schedule >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"isStopped") ) { isStopped=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_executor") ) { _executor=inValue.Cast<  ::hx::concurrent::executor::Executor >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void AbstractTaskFuture_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("schedule",57,ca,7e,c5));
	outFields->push(HX_("isStopped",43,4f,60,47));
	outFields->push(HX_("_executor",b2,e4,f1,06));
	outFields->push(HX_("_task",24,db,07,00));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo AbstractTaskFuture_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /*  ::hx::concurrent::executor::Schedule */ ,(int)offsetof(AbstractTaskFuture_obj,schedule),HX_("schedule",57,ca,7e,c5)},
	{::hx::fsBool,(int)offsetof(AbstractTaskFuture_obj,isStopped),HX_("isStopped",43,4f,60,47)},
	{::hx::fsObject /*  ::hx::concurrent::executor::Executor */ ,(int)offsetof(AbstractTaskFuture_obj,_executor),HX_("_executor",b2,e4,f1,06)},
	{::hx::fsObject /*  ::hx::concurrent::internal::_Either2::_Either2 */ ,(int)offsetof(AbstractTaskFuture_obj,_task),HX_("_task",24,db,07,00)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *AbstractTaskFuture_obj_sStaticStorageInfo = 0;
#endif

static ::String AbstractTaskFuture_obj_sMemberFields[] = {
	HX_("schedule",57,ca,7e,c5),
	HX_("isStopped",43,4f,60,47),
	HX_("_executor",b2,e4,f1,06),
	HX_("_task",24,db,07,00),
	HX_("cancel",7a,ed,33,b8),
	HX_("awaitCompletion",12,36,2e,b5),
	::String(null()) };

::hx::Class AbstractTaskFuture_obj::__mClass;

void AbstractTaskFuture_obj::__register()
{
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("hx.concurrent.executor.AbstractTaskFuture",2c,a4,65,77);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(AbstractTaskFuture_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< AbstractTaskFuture_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = AbstractTaskFuture_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = AbstractTaskFuture_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace hx
} // end namespace concurrent
} // end namespace executor
