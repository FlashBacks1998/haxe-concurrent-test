// Generated by Haxe 4.3.3
#include <hxcpp.h>

#ifndef INCLUDED_Date
#include <Date.h>
#endif
#ifndef INCLUDED_Sys
#include <Sys.h>
#endif
#ifndef INCLUDED_hx_concurrent_executor_Schedule
#include <hx/concurrent/executor/Schedule.h>
#endif
#ifndef INCLUDED_hx_concurrent_executor_ScheduleTools
#include <hx/concurrent/executor/ScheduleTools.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_7e488f5148e91a34_69_applyDefaults,"hx.concurrent.executor.ScheduleTools","applyDefaults",0x05085af4,"hx.concurrent.executor.ScheduleTools.applyDefaults","hx/concurrent/executor/Schedule.hx",69,0xc439bc84)
HX_LOCAL_STACK_FRAME(_hx_pos_7e488f5148e91a34_115_assertValid,"hx.concurrent.executor.ScheduleTools","assertValid",0x89e95e2a,"hx.concurrent.executor.ScheduleTools.assertValid","hx/concurrent/executor/Schedule.hx",115,0xc439bc84)
HX_LOCAL_STACK_FRAME(_hx_pos_7e488f5148e91a34_156_firstRunAt,"hx.concurrent.executor.ScheduleTools","firstRunAt",0xf6329b7a,"hx.concurrent.executor.ScheduleTools.firstRunAt","hx/concurrent/executor/Schedule.hx",156,0xc439bc84)
HX_LOCAL_STACK_FRAME(_hx_pos_7e488f5148e91a34_64_boot,"hx.concurrent.executor.ScheduleTools","boot",0x6a8303de,"hx.concurrent.executor.ScheduleTools.boot","hx/concurrent/executor/Schedule.hx",64,0xc439bc84)
HX_LOCAL_STACK_FRAME(_hx_pos_7e488f5148e91a34_65_boot,"hx.concurrent.executor.ScheduleTools","boot",0x6a8303de,"hx.concurrent.executor.ScheduleTools.boot","hx/concurrent/executor/Schedule.hx",65,0xc439bc84)
HX_LOCAL_STACK_FRAME(_hx_pos_7e488f5148e91a34_66_boot,"hx.concurrent.executor.ScheduleTools","boot",0x6a8303de,"hx.concurrent.executor.ScheduleTools.boot","hx/concurrent/executor/Schedule.hx",66,0xc439bc84)
namespace hx{
namespace concurrent{
namespace executor{

void ScheduleTools_obj::__construct() { }

Dynamic ScheduleTools_obj::__CreateEmpty() { return new ScheduleTools_obj; }

void *ScheduleTools_obj::_hx_vtable = 0;

Dynamic ScheduleTools_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< ScheduleTools_obj > _hx_result = new ScheduleTools_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool ScheduleTools_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x1f113f0a;
}

int ScheduleTools_obj::HOUR_IN_MS;

int ScheduleTools_obj::DAY_IN_MS;

int ScheduleTools_obj::WEEK_IN_MS;

 ::hx::concurrent::executor::Schedule ScheduleTools_obj::applyDefaults( ::hx::concurrent::executor::Schedule schedule){
            	HX_STACKFRAME(&_hx_pos_7e488f5148e91a34_69_applyDefaults)
HXLINE(  70)		switch((int)(schedule->_hx_getIndex())){
            			case (int)0: {
HXLINE(  71)				 ::Dynamic initialDelayMS = schedule->_hx_getObject(0);
HXLINE(  72)				if (::hx::IsNull( initialDelayMS )) {
HXLINE(  73)					return ::hx::concurrent::executor::Schedule_obj::ONCE(0);
            				}
            			}
            			break;
            			case (int)1: {
HXLINE(  75)				int intervalMS = schedule->_hx_getInt(0);
HXDLIN(  75)				 ::Dynamic initialDelayMS1 = schedule->_hx_getObject(1);
HXLINE(  76)				if (::hx::IsNull( initialDelayMS1 )) {
HXLINE(  77)					return ::hx::concurrent::executor::Schedule_obj::FIXED_DELAY(intervalMS,0);
            				}
            			}
            			break;
            			case (int)2: {
HXLINE(  79)				int intervalMS1 = schedule->_hx_getInt(0);
HXDLIN(  79)				 ::Dynamic initialDelayMS2 = schedule->_hx_getObject(1);
HXLINE(  80)				if (::hx::IsNull( initialDelayMS2 )) {
HXLINE(  81)					return ::hx::concurrent::executor::Schedule_obj::FIXED_RATE(intervalMS1,0);
            				}
            			}
            			break;
            			case (int)3: {
HXLINE(  83)				 ::Dynamic minute = schedule->_hx_getObject(0);
HXDLIN(  83)				 ::Dynamic second = schedule->_hx_getObject(1);
HXLINE(  84)				bool _hx_tmp;
HXDLIN(  84)				if (::hx::IsNotNull( minute )) {
HXLINE(  84)					_hx_tmp = ::hx::IsNull( second );
            				}
            				else {
HXLINE(  84)					_hx_tmp = true;
            				}
HXDLIN(  84)				if (_hx_tmp) {
HXLINE(  86)					 ::Dynamic _hx_tmp1;
HXDLIN(  86)					if (::hx::IsNull( minute )) {
HXLINE(  86)						_hx_tmp1 = 0;
            					}
            					else {
HXLINE(  86)						_hx_tmp1 = minute;
            					}
HXLINE(  87)					 ::Dynamic _hx_tmp2;
HXDLIN(  87)					if (::hx::IsNull( second )) {
HXLINE(  87)						_hx_tmp2 = 0;
            					}
            					else {
HXLINE(  87)						_hx_tmp2 = second;
            					}
HXLINE(  85)					return ::hx::concurrent::executor::Schedule_obj::HOURLY(_hx_tmp1,_hx_tmp2);
            				}
            			}
            			break;
            			case (int)4: {
HXLINE(  90)				 ::Dynamic hour = schedule->_hx_getObject(0);
HXDLIN(  90)				 ::Dynamic minute1 = schedule->_hx_getObject(1);
HXDLIN(  90)				 ::Dynamic second1 = schedule->_hx_getObject(2);
HXLINE(  91)				bool _hx_tmp3;
HXDLIN(  91)				bool _hx_tmp4;
HXDLIN(  91)				if (::hx::IsNotNull( hour )) {
HXLINE(  91)					_hx_tmp4 = ::hx::IsNull( minute1 );
            				}
            				else {
HXLINE(  91)					_hx_tmp4 = true;
            				}
HXDLIN(  91)				if (!(_hx_tmp4)) {
HXLINE(  91)					_hx_tmp3 = ::hx::IsNull( second1 );
            				}
            				else {
HXLINE(  91)					_hx_tmp3 = true;
            				}
HXDLIN(  91)				if (_hx_tmp3) {
HXLINE(  93)					 ::Dynamic _hx_tmp5;
HXDLIN(  93)					if (::hx::IsNull( hour )) {
HXLINE(  93)						_hx_tmp5 = 0;
            					}
            					else {
HXLINE(  93)						_hx_tmp5 = hour;
            					}
HXLINE(  94)					 ::Dynamic _hx_tmp6;
HXDLIN(  94)					if (::hx::IsNull( minute1 )) {
HXLINE(  94)						_hx_tmp6 = 0;
            					}
            					else {
HXLINE(  94)						_hx_tmp6 = minute1;
            					}
HXLINE(  95)					 ::Dynamic _hx_tmp7;
HXDLIN(  95)					if (::hx::IsNull( second1 )) {
HXLINE(  95)						_hx_tmp7 = 0;
            					}
            					else {
HXLINE(  95)						_hx_tmp7 = second1;
            					}
HXLINE(  92)					return ::hx::concurrent::executor::Schedule_obj::DAILY(_hx_tmp5,_hx_tmp6,_hx_tmp7);
            				}
            			}
            			break;
            			case (int)5: {
HXLINE(  98)				 ::Dynamic day = schedule->_hx_getObject(0);
HXDLIN(  98)				 ::Dynamic hour1 = schedule->_hx_getObject(1);
HXDLIN(  98)				 ::Dynamic minute2 = schedule->_hx_getObject(2);
HXDLIN(  98)				 ::Dynamic second2 = schedule->_hx_getObject(3);
HXLINE(  99)				bool _hx_tmp8;
HXDLIN(  99)				bool _hx_tmp9;
HXDLIN(  99)				bool _hx_tmp10;
HXDLIN(  99)				if (::hx::IsNotNull( day )) {
HXLINE(  99)					_hx_tmp10 = ::hx::IsNull( hour1 );
            				}
            				else {
HXLINE(  99)					_hx_tmp10 = true;
            				}
HXDLIN(  99)				if (!(_hx_tmp10)) {
HXLINE(  99)					_hx_tmp9 = ::hx::IsNull( minute2 );
            				}
            				else {
HXLINE(  99)					_hx_tmp9 = true;
            				}
HXDLIN(  99)				if (!(_hx_tmp9)) {
HXLINE(  99)					_hx_tmp8 = ::hx::IsNull( second2 );
            				}
            				else {
HXLINE(  99)					_hx_tmp8 = true;
            				}
HXDLIN(  99)				if (_hx_tmp8) {
HXLINE( 101)					 ::Dynamic _hx_tmp11;
HXDLIN( 101)					if (::hx::IsNull( day )) {
HXLINE( 101)						_hx_tmp11 = 0;
            					}
            					else {
HXLINE( 101)						_hx_tmp11 = day;
            					}
HXLINE( 102)					 ::Dynamic _hx_tmp12;
HXDLIN( 102)					if (::hx::IsNull( hour1 )) {
HXLINE( 102)						_hx_tmp12 = 0;
            					}
            					else {
HXLINE( 102)						_hx_tmp12 = hour1;
            					}
HXLINE( 103)					 ::Dynamic _hx_tmp13;
HXDLIN( 103)					if (::hx::IsNull( minute2 )) {
HXLINE( 103)						_hx_tmp13 = 0;
            					}
            					else {
HXLINE( 103)						_hx_tmp13 = minute2;
            					}
HXLINE( 104)					 ::Dynamic _hx_tmp14;
HXDLIN( 104)					if (::hx::IsNull( second2 )) {
HXLINE( 104)						_hx_tmp14 = 0;
            					}
            					else {
HXLINE( 104)						_hx_tmp14 = second2;
            					}
HXLINE( 100)					return ::hx::concurrent::executor::Schedule_obj::WEEKLY(_hx_tmp11,_hx_tmp12,_hx_tmp13,_hx_tmp14);
            				}
            			}
            			break;
            		}
HXLINE( 107)		return schedule;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(ScheduleTools_obj,applyDefaults,return )

 ::hx::concurrent::executor::Schedule ScheduleTools_obj::assertValid( ::hx::concurrent::executor::Schedule schedule){
            	HX_STACKFRAME(&_hx_pos_7e488f5148e91a34_115_assertValid)
HXLINE( 116)		schedule = ::hx::concurrent::executor::ScheduleTools_obj::applyDefaults(schedule);
HXLINE( 118)		switch((int)(schedule->_hx_getIndex())){
            			case (int)0: {
HXLINE( 119)				 ::Dynamic initialDelayMS = schedule->_hx_getObject(0);
HXLINE( 120)				if (::hx::IsLess( initialDelayMS,0 )) {
HXLINE( 121)					HX_STACK_DO_THROW(HX_("[Schedule.ONCE.initialDelayMS] must be >= 0",ce,e3,3e,39));
            				}
            			}
            			break;
            			case (int)1: {
HXLINE( 123)				int intervalMS = schedule->_hx_getInt(0);
HXDLIN( 123)				 ::Dynamic initialDelayMS1 = schedule->_hx_getObject(1);
HXDLIN( 123)				{
HXLINE( 124)					if ((intervalMS <= 0)) {
HXLINE( 125)						HX_STACK_DO_THROW(HX_("[Schedule.FIXED_DELAY.intervalMS] must be > 0",08,f1,80,96));
            					}
HXLINE( 126)					bool _hx_tmp;
HXDLIN( 126)					if (::hx::IsNotNull( initialDelayMS1 )) {
HXLINE( 126)						_hx_tmp = ::hx::IsLess( initialDelayMS1,0 );
            					}
            					else {
HXLINE( 126)						_hx_tmp = true;
            					}
HXDLIN( 126)					if (_hx_tmp) {
HXLINE( 127)						HX_STACK_DO_THROW(HX_("[Schedule.FIXED_DELAY.initialDelayMS] must be >= 0",af,2d,2b,26));
            					}
            				}
            			}
            			break;
            			case (int)2: {
HXLINE( 129)				int intervalMS1 = schedule->_hx_getInt(0);
HXDLIN( 129)				 ::Dynamic initialDelayMS2 = schedule->_hx_getObject(1);
HXDLIN( 129)				{
HXLINE( 130)					if ((intervalMS1 <= 0)) {
HXLINE( 131)						HX_STACK_DO_THROW(HX_("[Schedule.FIXED_RATE.intervalMS] must be > 0",b3,c9,62,12));
            					}
HXLINE( 132)					if (::hx::IsLess( initialDelayMS2,0 )) {
HXLINE( 133)						HX_STACK_DO_THROW(HX_("[Schedule.FIXED_RATE.initialDelayMS] must be >= 0",24,09,a1,6f));
            					}
            				}
            			}
            			break;
            			case (int)3: {
HXLINE( 135)				 ::Dynamic minute = schedule->_hx_getObject(0);
HXDLIN( 135)				 ::Dynamic second = schedule->_hx_getObject(1);
HXDLIN( 135)				{
HXLINE( 136)					bool _hx_tmp1;
HXDLIN( 136)					if (::hx::IsNotNull( minute )) {
HXLINE( 136)						_hx_tmp1 = ::hx::IsLess( minute,0 );
            					}
            					else {
HXLINE( 136)						_hx_tmp1 = true;
            					}
HXDLIN( 136)					if (_hx_tmp1) {
HXLINE( 136)						HX_STACK_DO_THROW(HX_("[Schedule.DAILY.minute] must be between >= 0 and <= 59",ef,67,80,6d));
            					}
HXLINE( 137)					bool _hx_tmp2;
HXDLIN( 137)					if (::hx::IsNotNull( second )) {
HXLINE( 137)						_hx_tmp2 = ::hx::IsLess( second,0 );
            					}
            					else {
HXLINE( 137)						_hx_tmp2 = true;
            					}
HXDLIN( 137)					if (_hx_tmp2) {
HXLINE( 137)						HX_STACK_DO_THROW(HX_("[Schedule.DAILY.second] must be between >= 0 and <= 59",8f,d4,36,f1));
            					}
            				}
            			}
            			break;
            			case (int)4: {
HXLINE( 139)				 ::Dynamic hour = schedule->_hx_getObject(0);
HXDLIN( 139)				 ::Dynamic minute1 = schedule->_hx_getObject(1);
HXDLIN( 139)				 ::Dynamic second1 = schedule->_hx_getObject(2);
HXDLIN( 139)				{
HXLINE( 140)					bool _hx_tmp3;
HXDLIN( 140)					if (::hx::IsNotNull( hour )) {
HXLINE( 140)						_hx_tmp3 = ::hx::IsLess( hour,0 );
            					}
            					else {
HXLINE( 140)						_hx_tmp3 = true;
            					}
HXDLIN( 140)					if (_hx_tmp3) {
HXLINE( 140)						HX_STACK_DO_THROW(HX_("[Schedule.DAILY.hour] must be between >= 0 and <= 23",5c,75,68,dd));
            					}
HXLINE( 141)					bool _hx_tmp4;
HXDLIN( 141)					if (::hx::IsNotNull( minute1 )) {
HXLINE( 141)						_hx_tmp4 = ::hx::IsLess( minute1,0 );
            					}
            					else {
HXLINE( 141)						_hx_tmp4 = true;
            					}
HXDLIN( 141)					if (_hx_tmp4) {
HXLINE( 141)						HX_STACK_DO_THROW(HX_("[Schedule.DAILY.minute] must be between >= 0 and <= 59",ef,67,80,6d));
            					}
HXLINE( 142)					bool _hx_tmp5;
HXDLIN( 142)					if (::hx::IsNotNull( second1 )) {
HXLINE( 142)						_hx_tmp5 = ::hx::IsLess( second1,0 );
            					}
            					else {
HXLINE( 142)						_hx_tmp5 = true;
            					}
HXDLIN( 142)					if (_hx_tmp5) {
HXLINE( 142)						HX_STACK_DO_THROW(HX_("[Schedule.DAILY.second] must be between >= 0 and <= 59",8f,d4,36,f1));
            					}
            				}
            			}
            			break;
            			case (int)5: {
HXLINE( 144)				 ::Dynamic day = schedule->_hx_getObject(0);
HXDLIN( 144)				 ::Dynamic hour1 = schedule->_hx_getObject(1);
HXDLIN( 144)				 ::Dynamic minute2 = schedule->_hx_getObject(2);
HXDLIN( 144)				 ::Dynamic second2 = schedule->_hx_getObject(3);
HXDLIN( 144)				{
HXLINE( 145)					bool _hx_tmp6;
HXDLIN( 145)					if (::hx::IsNotNull( hour1 )) {
HXLINE( 145)						_hx_tmp6 = ::hx::IsLess( hour1,0 );
            					}
            					else {
HXLINE( 145)						_hx_tmp6 = true;
            					}
HXDLIN( 145)					if (_hx_tmp6) {
HXLINE( 145)						HX_STACK_DO_THROW(HX_("[Schedule.WEEKLY.hour] must be between >= 0 and <= 23",dc,ee,8d,27));
            					}
HXLINE( 146)					bool _hx_tmp7;
HXDLIN( 146)					if (::hx::IsNotNull( minute2 )) {
HXLINE( 146)						_hx_tmp7 = ::hx::IsLess( minute2,0 );
            					}
            					else {
HXLINE( 146)						_hx_tmp7 = true;
            					}
HXDLIN( 146)					if (_hx_tmp7) {
HXLINE( 146)						HX_STACK_DO_THROW(HX_("[Schedule.WEEKLY.minute] must be between >= 0 and <= 59",6f,41,17,a7));
            					}
HXLINE( 147)					bool _hx_tmp8;
HXDLIN( 147)					if (::hx::IsNotNull( second2 )) {
HXLINE( 147)						_hx_tmp8 = ::hx::IsLess( second2,0 );
            					}
            					else {
HXLINE( 147)						_hx_tmp8 = true;
            					}
HXDLIN( 147)					if (_hx_tmp8) {
HXLINE( 147)						HX_STACK_DO_THROW(HX_("[Schedule.WEEKLY.second] must be between >= 0 and <= 59",0f,ae,cd,2a));
            					}
            				}
            			}
            			break;
            		}
HXLINE( 149)		return schedule;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(ScheduleTools_obj,assertValid,return )

Float ScheduleTools_obj::firstRunAt( ::hx::concurrent::executor::Schedule schedule){
            	HX_STACKFRAME(&_hx_pos_7e488f5148e91a34_156_firstRunAt)
HXLINE( 158)		schedule = ::hx::concurrent::executor::ScheduleTools_obj::assertValid(schedule);
HXLINE( 162)		switch((int)(schedule->_hx_getIndex())){
            			case (int)0: {
HXLINE( 163)				 ::Dynamic initialDelayMS = schedule->_hx_getObject(0);
HXDLIN( 163)				return ((::Sys_obj::time() * ( (Float)(1000) )) + initialDelayMS);
            			}
            			break;
            			case (int)1: {
HXLINE( 164)				int intervalMS = schedule->_hx_getInt(0);
HXDLIN( 164)				 ::Dynamic initialDelayMS1 = schedule->_hx_getObject(1);
HXDLIN( 164)				return ((::Sys_obj::time() * ( (Float)(1000) )) + initialDelayMS1);
            			}
            			break;
            			case (int)2: {
HXLINE( 165)				int intervalMS1 = schedule->_hx_getInt(0);
HXDLIN( 165)				 ::Dynamic initialDelayMS2 = schedule->_hx_getObject(1);
HXDLIN( 165)				return ((::Sys_obj::time() * ( (Float)(1000) )) + initialDelayMS2);
            			}
            			break;
            			case (int)3: {
HXLINE( 167)				 ::Dynamic minute = schedule->_hx_getObject(0);
HXDLIN( 167)				 ::Dynamic second = schedule->_hx_getObject(1);
HXLINE( 168)				Float nowMS = (::Sys_obj::time() * ( (Float)(1000) ));
HXLINE( 169)				 ::Date now = ::Date_obj::fromTime(nowMS);
HXLINE( 171)				int runAtSecondOfHour = ((( (int)(minute) ) * 60) + second);
HXLINE( 172)				int elapsedSecondsThisHour = (now->getMinutes() * 60);
HXDLIN( 172)				int elapsedSecondsThisHour1 = (elapsedSecondsThisHour + now->getSeconds());
HXLINE( 176)				int _hx_tmp;
HXDLIN( 176)				if ((elapsedSecondsThisHour1 > runAtSecondOfHour)) {
HXLINE( 176)					_hx_tmp = 3600000;
            				}
            				else {
HXLINE( 176)					_hx_tmp = 0;
            				}
HXLINE( 174)				return ((nowMS + ((runAtSecondOfHour - elapsedSecondsThisHour1) * 1000)) + _hx_tmp);
            			}
            			break;
            			case (int)4: {
HXLINE( 178)				 ::Dynamic hour = schedule->_hx_getObject(0);
HXDLIN( 178)				 ::Dynamic minute1 = schedule->_hx_getObject(1);
HXDLIN( 178)				 ::Dynamic second1 = schedule->_hx_getObject(2);
HXLINE( 179)				Float nowMS1 = (::Sys_obj::time() * ( (Float)(1000) ));
HXLINE( 180)				 ::Date now1 = ::Date_obj::fromTime(nowMS1);
HXLINE( 182)				int runAtSecondOfDay = ((((( (int)(hour) ) * 60) * 60) + (( (int)(minute1) ) * 60)) + second1);
HXLINE( 183)				int elapsedSecondsToday = ((now1->getHours() * 60) * 60);
HXDLIN( 183)				int elapsedSecondsToday1 = (elapsedSecondsToday + (now1->getMinutes() * 60));
HXDLIN( 183)				int elapsedSecondsToday2 = (elapsedSecondsToday1 + now1->getSeconds());
HXLINE( 185)				int _hx_tmp1;
HXDLIN( 185)				if ((elapsedSecondsToday2 > runAtSecondOfDay)) {
HXLINE( 185)					_hx_tmp1 = 86400000;
            				}
            				else {
HXLINE( 185)					_hx_tmp1 = 0;
            				}
HXDLIN( 185)				return ((nowMS1 + ((runAtSecondOfDay - elapsedSecondsToday2) * 1000)) + _hx_tmp1);
            			}
            			break;
            			case (int)5: {
HXLINE( 188)				 ::Dynamic day = schedule->_hx_getObject(0);
HXDLIN( 188)				 ::Dynamic hour1 = schedule->_hx_getObject(1);
HXDLIN( 188)				 ::Dynamic minute2 = schedule->_hx_getObject(2);
HXDLIN( 188)				 ::Dynamic second2 = schedule->_hx_getObject(3);
HXLINE( 189)				Float nowMS2 = (::Sys_obj::time() * ( (Float)(1000) ));
HXLINE( 190)				 ::Date now2 = ::Date_obj::fromTime(nowMS2);
HXLINE( 192)				int runAtSecondOfDay1 = ((((( (int)(hour1) ) * 60) * 60) + (( (int)(minute2) ) * 60)) + second2);
HXLINE( 193)				int elapsedSecondsToday3 = ((now2->getHours() * 60) * 60);
HXDLIN( 193)				int elapsedSecondsToday4 = (elapsedSecondsToday3 + (now2->getMinutes() * 60));
HXDLIN( 193)				int elapsedSecondsToday5 = (elapsedSecondsToday4 + now2->getSeconds());
HXLINE( 195)				int dayIndex = ( (int)(day) );
HXLINE( 196)				if ((dayIndex == now2->getDay())) {
HXLINE( 197)					int _hx_tmp2;
HXDLIN( 197)					if ((elapsedSecondsToday5 > runAtSecondOfDay1)) {
HXLINE( 197)						_hx_tmp2 = 604800000;
            					}
            					else {
HXLINE( 197)						_hx_tmp2 = 0;
            					}
HXDLIN( 197)					return ((nowMS2 + ((runAtSecondOfDay1 - elapsedSecondsToday5) * 1000)) + _hx_tmp2);
            				}
            				else {
HXLINE( 198)					if ((now2->getDate() < dayIndex)) {
HXLINE( 199)						return ((nowMS2 + ((runAtSecondOfDay1 - elapsedSecondsToday5) * 1000)) + (86400000 * (dayIndex - now2->getDate())));
            					}
            					else {
HXLINE( 201)						return ((nowMS2 + ((runAtSecondOfDay1 - elapsedSecondsToday5) * 1000)) + (86400000 * (7 - (dayIndex - now2->getDate()))));
            					}
            				}
            			}
            			break;
            		}
HXLINE( 162)		return ((Float)0.);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(ScheduleTools_obj,firstRunAt,return )


ScheduleTools_obj::ScheduleTools_obj()
{
}

bool ScheduleTools_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 10:
		if (HX_FIELD_EQ(inName,"firstRunAt") ) { outValue = firstRunAt_dyn(); return true; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"assertValid") ) { outValue = assertValid_dyn(); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"applyDefaults") ) { outValue = applyDefaults_dyn(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *ScheduleTools_obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo ScheduleTools_obj_sStaticStorageInfo[] = {
	{::hx::fsInt,(void *) &ScheduleTools_obj::HOUR_IN_MS,HX_("HOUR_IN_MS",25,aa,0f,b5)},
	{::hx::fsInt,(void *) &ScheduleTools_obj::DAY_IN_MS,HX_("DAY_IN_MS",3d,c5,e3,3a)},
	{::hx::fsInt,(void *) &ScheduleTools_obj::WEEK_IN_MS,HX_("WEEK_IN_MS",f5,34,c1,05)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static void ScheduleTools_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(ScheduleTools_obj::HOUR_IN_MS,"HOUR_IN_MS");
	HX_MARK_MEMBER_NAME(ScheduleTools_obj::DAY_IN_MS,"DAY_IN_MS");
	HX_MARK_MEMBER_NAME(ScheduleTools_obj::WEEK_IN_MS,"WEEK_IN_MS");
};

#ifdef HXCPP_VISIT_ALLOCS
static void ScheduleTools_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(ScheduleTools_obj::HOUR_IN_MS,"HOUR_IN_MS");
	HX_VISIT_MEMBER_NAME(ScheduleTools_obj::DAY_IN_MS,"DAY_IN_MS");
	HX_VISIT_MEMBER_NAME(ScheduleTools_obj::WEEK_IN_MS,"WEEK_IN_MS");
};

#endif

::hx::Class ScheduleTools_obj::__mClass;

static ::String ScheduleTools_obj_sStaticFields[] = {
	HX_("HOUR_IN_MS",25,aa,0f,b5),
	HX_("DAY_IN_MS",3d,c5,e3,3a),
	HX_("WEEK_IN_MS",f5,34,c1,05),
	HX_("applyDefaults",20,30,cf,ef),
	HX_("assertValid",56,50,ee,33),
	HX_("firstRunAt",ce,12,36,2f),
	::String(null())
};

void ScheduleTools_obj::__register()
{
	ScheduleTools_obj _hx_dummy;
	ScheduleTools_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("hx.concurrent.executor.ScheduleTools",42,00,75,2e);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &ScheduleTools_obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = ScheduleTools_obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(ScheduleTools_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< ScheduleTools_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = ScheduleTools_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = ScheduleTools_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = ScheduleTools_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void ScheduleTools_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_7e488f5148e91a34_64_boot)
HXDLIN(  64)		HOUR_IN_MS = 3600000;
            	}
{
            	HX_STACKFRAME(&_hx_pos_7e488f5148e91a34_65_boot)
HXDLIN(  65)		DAY_IN_MS = 86400000;
            	}
{
            	HX_STACKFRAME(&_hx_pos_7e488f5148e91a34_66_boot)
HXDLIN(  66)		WEEK_IN_MS = 604800000;
            	}
}

} // end namespace hx
} // end namespace concurrent
} // end namespace executor
