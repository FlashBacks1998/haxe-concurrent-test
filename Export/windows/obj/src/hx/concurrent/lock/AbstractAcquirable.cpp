// Generated by Haxe 4.3.3
#include <hxcpp.h>

#ifndef INCLUDED_haxe_Exception
#include <haxe/Exception.h>
#endif
#ifndef INCLUDED_hx_concurrent_ConcurrentException
#include <hx/concurrent/ConcurrentException.h>
#endif
#ifndef INCLUDED_hx_concurrent_lock_AbstractAcquirable
#include <hx/concurrent/lock/AbstractAcquirable.h>
#endif
#ifndef INCLUDED_hx_concurrent_lock_Acquirable
#include <hx/concurrent/lock/Acquirable.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_bd58dee22b16e3d5_49_execute,"hx.concurrent.lock.AbstractAcquirable","execute",0x53f4cf3c,"hx.concurrent.lock.AbstractAcquirable.execute","hx/concurrent/lock/Acquirable.hx",49,0x07fd2caa)
namespace hx{
namespace concurrent{
namespace lock{

void AbstractAcquirable_obj::__construct() { }

bool AbstractAcquirable_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x22633cdd;
}

static ::hx::concurrent::lock::Acquirable_obj _hx_hx_concurrent_lock_AbstractAcquirable__hx_hx_concurrent_lock_Acquirable= {
	( int (::hx::Object::*)())&::hx::concurrent::lock::AbstractAcquirable_obj::get_availablePermits,
	( void (::hx::Object::*)())&::hx::concurrent::lock::AbstractAcquirable_obj::acquire,
	( bool (::hx::Object::*)(::hx::Null< int > ))&::hx::concurrent::lock::AbstractAcquirable_obj::tryAcquire,
	( void (::hx::Object::*)())&::hx::concurrent::lock::AbstractAcquirable_obj::release,
	(  ::Dynamic (::hx::Object::*)( ::Dynamic,::hx::Null< bool > ))&::hx::concurrent::lock::AbstractAcquirable_obj::execute,
};

void *AbstractAcquirable_obj::_hx_getInterface(int inHash) {
	switch(inHash) {
		case (int)0x3a6fb49b: return &_hx_hx_concurrent_lock_AbstractAcquirable__hx_hx_concurrent_lock_Acquirable;
	}
	#ifdef HXCPP_SCRIPTABLE
	return super::_hx_getInterface(inHash);
	#else
	return 0;
	#endif
}

HX_DEFINE_DYNAMIC_FUNC1(AbstractAcquirable_obj,tryAcquire,return )

HX_DEFINE_DYNAMIC_FUNC0(AbstractAcquirable_obj,release,(void))

HX_DEFINE_DYNAMIC_FUNC0(AbstractAcquirable_obj,acquire,(void))

HX_DEFINE_DYNAMIC_FUNC0(AbstractAcquirable_obj,get_availablePermits,return )

 ::Dynamic AbstractAcquirable_obj::execute( ::Dynamic func,::hx::Null< bool >  __o_swallowExceptions){
            		bool swallowExceptions = __o_swallowExceptions.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_bd58dee22b16e3d5_49_execute)
HXLINE(  50)		 ::hx::concurrent::ConcurrentException ex = null();
HXLINE(  51)		 ::Dynamic result = null();
HXLINE(  53)		this->acquire();
HXLINE(  54)		try {
            			HX_STACK_CATCHABLE( ::Dynamic, 0);
HXLINE(  55)			result = func();
            		} catch( ::Dynamic _hx_e) {
            			if (_hx_e.IsClass<  ::Dynamic >() ){
            				HX_STACK_BEGIN_CATCH
            				 ::Dynamic _g = _hx_e;
HXLINE(  56)				 ::haxe::Exception e = ::haxe::Exception_obj::caught(_g);
HXLINE(  57)				ex =  ::hx::concurrent::ConcurrentException_obj::__alloc( HX_CTX ,e);
            			}
            			else {
            				HX_STACK_DO_THROW(_hx_e);
            			}
            		}
HXLINE(  59)		this->release();
HXLINE(  61)		bool _hx_tmp;
HXDLIN(  61)		if (!(swallowExceptions)) {
HXLINE(  61)			_hx_tmp = ::hx::IsNotNull( ex );
            		}
            		else {
HXLINE(  61)			_hx_tmp = false;
            		}
HXDLIN(  61)		if (_hx_tmp) {
HXLINE(  62)			HX_STACK_DO_THROW(ex->toString());
            		}
HXLINE(  64)		return result;
            	}


HX_DEFINE_DYNAMIC_FUNC2(AbstractAcquirable_obj,execute,return )


AbstractAcquirable_obj::AbstractAcquirable_obj()
{
}

::hx::Val AbstractAcquirable_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 7:
		if (HX_FIELD_EQ(inName,"release") ) { return ::hx::Val( release_dyn() ); }
		if (HX_FIELD_EQ(inName,"acquire") ) { return ::hx::Val( acquire_dyn() ); }
		if (HX_FIELD_EQ(inName,"execute") ) { return ::hx::Val( execute_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"tryAcquire") ) { return ::hx::Val( tryAcquire_dyn() ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"availablePermits") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( get_availablePermits() ); }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"get_availablePermits") ) { return ::hx::Val( get_availablePermits_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

void AbstractAcquirable_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("availablePermits",6f,64,f0,8d));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *AbstractAcquirable_obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *AbstractAcquirable_obj_sStaticStorageInfo = 0;
#endif

static ::String AbstractAcquirable_obj_sMemberFields[] = {
	HX_("tryAcquire",db,77,4c,9c),
	HX_("release",c7,85,ed,58),
	HX_("acquire",d6,4b,e4,b4),
	HX_("get_availablePermits",78,c9,5a,ac),
	HX_("execute",35,0a,0d,cc),
	::String(null()) };

::hx::Class AbstractAcquirable_obj::__mClass;

void AbstractAcquirable_obj::__register()
{
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("hx.concurrent.lock.AbstractAcquirable",75,46,cc,29);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(AbstractAcquirable_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< AbstractAcquirable_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = AbstractAcquirable_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = AbstractAcquirable_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace hx
} // end namespace concurrent
} // end namespace lock
