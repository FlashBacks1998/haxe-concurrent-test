// Generated by Haxe 4.3.3
#include <hxcpp.h>

#ifndef INCLUDED_Sys
#include <Sys.h>
#endif
#ifndef INCLUDED_hx_concurrent_thread_Threads
#include <hx/concurrent/thread/Threads.h>
#endif
#ifndef INCLUDED_sys_thread__Thread_HaxeThread
#include <sys/thread/_Thread/HaxeThread.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_fc28c8c834961572_28_get_current,"hx.concurrent.thread.Threads","get_current",0x6a4f9800,"hx.concurrent.thread.Threads.get_current","hx/concurrent/thread/Threads.hx",28,0x105a9f01)
HX_LOCAL_STACK_FRAME(_hx_pos_fc28c8c834961572_53_get_isSupported,"hx.concurrent.thread.Threads","get_isSupported",0xcbcd682b,"hx.concurrent.thread.Threads.get_isSupported","hx/concurrent/thread/Threads.hx",53,0x105a9f01)
HX_LOCAL_STACK_FRAME(_hx_pos_fc28c8c834961572_69_await,"hx.concurrent.thread.Threads","await",0x319d5706,"hx.concurrent.thread.Threads.await","hx/concurrent/thread/Threads.hx",69,0x105a9f01)
HX_LOCAL_STACK_FRAME(_hx_pos_fc28c8c834961572_109_sleep,"hx.concurrent.thread.Threads","sleep",0x879174c7,"hx.concurrent.thread.Threads.sleep","hx/concurrent/thread/Threads.hx",109,0x105a9f01)
HX_LOCAL_STACK_FRAME(_hx_pos_fc28c8c834961572_122_spawn,"hx.concurrent.thread.Threads","spawn",0x8a3355eb,"hx.concurrent.thread.Threads.spawn","hx/concurrent/thread/Threads.hx",122,0x105a9f01)
namespace hx{
namespace concurrent{
namespace thread{

void Threads_obj::__construct() { }

Dynamic Threads_obj::__CreateEmpty() { return new Threads_obj; }

void *Threads_obj::_hx_vtable = 0;

Dynamic Threads_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Threads_obj > _hx_result = new Threads_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Threads_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x37095418;
}

 ::Dynamic Threads_obj::get_current(){
            	HX_STACKFRAME(&_hx_pos_fc28c8c834961572_28_get_current)
HXDLIN(  28)		return ::sys::thread::_Thread::HaxeThread_obj::current();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(Threads_obj,get_current,return )

bool Threads_obj::get_isSupported(){
            	HX_STACKFRAME(&_hx_pos_fc28c8c834961572_53_get_isSupported)
HXDLIN(  53)		return true;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(Threads_obj,get_isSupported,return )

bool Threads_obj::await( ::Dynamic condition,int timeoutMS,::hx::Null< int >  __o_waitLoopSleepMS){
            		int waitLoopSleepMS = __o_waitLoopSleepMS.Default(10);
            	HX_STACKFRAME(&_hx_pos_fc28c8c834961572_69_await)
HXLINE(  70)		if ((timeoutMS < -1)) {
HXLINE(  71)			HX_STACK_DO_THROW(HX_("[timeoutMS] must be >= -1",70,77,1b,12));
            		}
HXLINE(  73)		if ((timeoutMS == 0)) {
HXLINE(  74)			return ( (bool)(condition()) );
            		}
HXLINE(  79)		Float waitLoopSleepSecs = (( (Float)(waitLoopSleepMS) ) / ((Float)1000.0));
HXLINE(  82)		Float startAt = (::Sys_obj::time() * ( (Float)(1000) ));
HXLINE(  83)		while(!(( (bool)(condition()) ))){
HXLINE(  84)			if ((timeoutMS > 0)) {
HXLINE(  85)				Float elapsedMS = ((::Sys_obj::time() * ( (Float)(1000) )) - startAt);
HXLINE(  86)				if ((elapsedMS >= timeoutMS)) {
HXLINE(  87)					return false;
            				}
            			}
HXLINE(  93)			::Sys_obj::sleep(waitLoopSleepSecs);
            		}
HXLINE(  96)		return true;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Threads_obj,await,return )

void Threads_obj::sleep(int timeMS){
            	HX_STACKFRAME(&_hx_pos_fc28c8c834961572_109_sleep)
HXDLIN( 109)		::Sys_obj::sleep((( (Float)(timeMS) ) / ( (Float)(1000) )));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Threads_obj,sleep,(void))

void Threads_obj::spawn( ::Dynamic func){
            	HX_STACKFRAME(&_hx_pos_fc28c8c834961572_122_spawn)
HXDLIN( 122)		::sys::thread::_Thread::HaxeThread_obj::create(func,false);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Threads_obj,spawn,(void))


Threads_obj::Threads_obj()
{
}

bool Threads_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"await") ) { outValue = await_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"sleep") ) { outValue = sleep_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"spawn") ) { outValue = spawn_dyn(); return true; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"current") ) { if (inCallProp == ::hx::paccAlways) { outValue = ( get_current() ); return true; } }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"get_current") ) { outValue = get_current_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"isSupported") ) { if (inCallProp == ::hx::paccAlways) { outValue = ( get_isSupported() ); return true; } }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"get_isSupported") ) { outValue = get_isSupported_dyn(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *Threads_obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *Threads_obj_sStaticStorageInfo = 0;
#endif

::hx::Class Threads_obj::__mClass;

static ::String Threads_obj_sStaticFields[] = {
	HX_("get_current",50,fc,dd,51),
	HX_("get_isSupported",7b,34,6c,b4),
	HX_("await",56,9f,d0,28),
	HX_("sleep",17,bd,c4,7e),
	HX_("spawn",3b,9e,66,81),
	::String(null())
};

void Threads_obj::__register()
{
	Threads_obj _hx_dummy;
	Threads_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("hx.concurrent.thread.Threads",1e,34,7f,3f);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Threads_obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(Threads_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< Threads_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Threads_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Threads_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace hx
} // end namespace concurrent
} // end namespace thread
